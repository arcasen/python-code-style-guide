### 函数和方法装饰器 

当有明显优势时，谨慎使用装饰器。避免 `staticmethod`，并限制使用 `classmethod`。

#### 定义 

函数和方法的装饰器^[<https://docs.python.org/3/glossary.html#term-decorator>]（又称“@ 符号”）。一个常见的装饰器是 `@property`，用于将普通方法转换为动态计算的属性。然而，装饰器语法也允许用户定义装饰器。具体来说，对于某些函数 `my_decorator`，这：

```python
class C:
    @my_decorator
    def method(self):
        # method body ...
```

等价于：

```python
class C:
    def method(self):
        # method body ...
    method = my_decorator(method)
```

#### 优点 

优雅地指定对方法的某些转换；转换可能消除一些重复代码、强制不变性等。

#### 缺点 

装饰器可以对函数的参数或返回值执行任意操作，导致意外的隐式行为。此外，装饰器在对象定义时执行。对于模块级对象（类、模块函数等），这发生在导入时。装饰器代码中的失败几乎不可能恢复。

#### 决定 

当有明显优势时，谨慎使用装饰器。装饰器应遵循与函数相同的导入和命名指南。装饰器文档字符串应清楚说明函数是装饰器。为装饰器编写单元测试。

避免装饰器本身中的外部依赖（例如，不要依赖文件、套接字、数据库连接等），因为在装饰器运行时（导入时，可能来自 `pydoc` 或其他工具）它们可能不可用。用有效参数调用装饰器应（尽可能）保证在所有情况下成功。

装饰器是“顶级代码”的特殊情况 - 有关更多讨论，请参阅[主程序]。

除非被迫整合现有库中定义的 API，否则不要使用 `staticmethod`。改为编写模块级函数。

仅当编写命名构造函数，或修改必要全局状态（如进程范围缓存）的类特定例程时，使用 `classmethod`。
